'use strict';

var fs = require('fs');
var path = require('path');
var typescript = require('typescript');

var StripWhitespace = /** @class */ (function () {
    function StripWhitespace(options) {
        if (options === void 0) { options = {}; }
        this.shouldStripWhitespace = options.shouldStripWhitespace || returnTrue;
    }
    StripWhitespace.prototype.strip = function (code) {
        var sourceFile = typescript.createSourceFile('', code, typescript.ScriptTarget.Latest, true);
        var replacements = this.getStringReplacements(sourceFile);
        var sortedReplacements = this.sortReplacements(replacements);
        code = this.makeAllReplacements(code, sortedReplacements);
        return { code: code, replacements: sortedReplacements };
    };
    StripWhitespace.prototype.stripString = function (fatString) {
        return fatString.replace(/[\s]+/g, ' ');
    };
    StripWhitespace.prototype.getStringReplacements = function (startingNode) {
        var _this = this;
        var stringList = [];
        var walk = this.createWalker(function (node) {
            if (node.kind !== typescript.SyntaxKind.StringLiteral) {
                return;
            }
            // make sure this string is not part of an property assignment { "a": 123 }
            if (node.parent && node.parent.kind === typescript.SyntaxKind.PropertyAssignment) {
                if (node.parent.getChildAt(0) === node) {
                    return;
                }
            }
            var text = node.text;
            if (!_this.shouldStripWhitespace(text)) {
                return;
            }
            var strippedText = _this.stripString(text);
            if (text === strippedText) {
                return;
            }
            stringList.push({
                end: node.getEnd() - 1,
                start: node.getStart() + 1,
                text: strippedText
            });
        });
        walk(startingNode);
        return this.sortReplacements(stringList);
    };
    StripWhitespace.prototype.makeAllReplacements = function (code, replacements) {
        var codeBuffer = [];
        var cursor = 0;
        for (var _i = 0, replacements_1 = replacements; _i < replacements_1.length; _i++) {
            var replacement = replacements_1[_i];
            codeBuffer.push(code.substring(cursor, replacement.start));
            codeBuffer.push(replacement.text);
            cursor = replacement.end;
        }
        codeBuffer.push(code.substring(cursor, code.length));
        return codeBuffer.join('');
    };
    StripWhitespace.prototype.sortReplacements = function (replacements) {
        return replacements.sort(function (a, b) { return a.start > b.start ? 1 : a.start < b.start ? -1 : 0; });
    };
    StripWhitespace.prototype.createWalker = function (traverser) {
        var walker = function (node) {
            traverser(node);
            typescript.forEachChild(node, walker);
        };
        return walker;
    };
    return StripWhitespace;
}());
function returnTrue() {
    return true;
}

// tslint:disable:no-var-requires
var config = require('./package.json');
process.title = config.name;
var options = parseArguments(process);
processFiles(options);
function processFiles(opt) {
    if (opt.input && opt.output) {
        fs.readFile(opt.input, 'utf-8', function (err, code) {
            if (err || !opt.output) {
                console.error(err);
            }
            else {
                var stripWhitespace = new StripWhitespace();
                var cleanCode = stripWhitespace.strip(code).code;
                fs.writeFile(opt.output, cleanCode, handleError);
            }
        });
    }
    else {
        printHelp();
    }
}
function handleError(err) {
    if (err) {
        console.error(err);
    }
}
function printHelp() {
    process.stdout.write(config.name + ' ' + config.version + '\n' +
        '\n' +
        'Usage: strip-whitespace --input <file> --output <file>');
}
function parseArguments(process) {
    var parsedOptions = {};
    process.argv.forEach(function (val, idx) {
        switch (val) {
            case '--input':
            case '-i':
                var inputFile = process.argv[idx + 1];
                parsedOptions.input = path.resolve(inputFile);
                break;
            case '--output':
            case '-o':
                var outputFile = process.argv[idx + 1];
                parsedOptions.output = path.resolve(outputFile);
                break;
            default:
                break;
        }
    });
    return parsedOptions;
}
//# sourceMappingURL=cli.js.map
